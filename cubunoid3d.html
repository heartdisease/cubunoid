<!doctype html>
<html>
	<head>
		<title>Cubunoid 1.0b</title>
		<script src="js/utils/webgl-utils.js" type="text/javascript"></script>
		<script src="js/utils/gl-matrix-min.js" type="text/javascript"></script>
		<script src="js/geometry.js" type="text/javascript"></script>
		<script src="js/input.js" type="text/javascript"></script>
		<script src="js/logic.js" type="text/javascript"></script>
		<script src="js/animation.js" type="text/javascript"></script>
		<script src="js/engine.js" type="text/javascript"></script>
		<script id="shader-vs" type="x-shader/x-vertex">
			// Per-Pixel Lighting
			// http://msdn.microsoft.com/en-us/library/ms810494
			precision mediump float;
			
			attribute vec3 aVertex;
			attribute vec3 aNormal;
			attribute vec2 aTexCoord;

			uniform mat4 uNMatrix;
			uniform mat4 uMvMatrix;
			uniform mat4 uMvpMatrix;
			uniform int  uTextureMode;
			
			vec3 eyePos = vec3(0.0, 0.0, 0.0);
			
			varying vec4 vColor;
			varying vec3 vNormal;
			varying vec2 vTexCoord;
			varying vec3 vEye;
			
			void main(void) {
				vColor      = vec4(aNormal, 1.0);
				vNormal     = normalize((uNMatrix * vec4(aNormal, 1.0)).xyz);
				vEye        = normalize((uMvMatrix * vec4(eyePos, 1.0)).xyz);
				if (uTextureMode != 0)
					vTexCoord = aTexCoord;
				
				gl_Position = uMvpMatrix * vec4(aVertex, 1.0);
			}
		</script>
		<script id="shader-fs-phong" type="x-shader/x-fragment">
			// http://www.arcsynthesis.org/gltut/Illumination/Tut11%20BlinnPhong%20Model.html
			// http://www.opengl.org/sdk/docs/tutorials/ClockworkCoders/lighting.php
			precision mediump float;
			
			struct LightSource {
				vec4 ambient;
				vec4 diffuse;
				vec4 specular;
				vec3 position;
			};
			
			struct Material {
				vec4 ambient;
				vec4 diffuse;
				vec4 specular;
				float shininess;
			};
			
			LightSource light0 = LightSource(
				vec4(1.0, 1.0, 1.0, 1.0),
				vec4(0.7, 0.7, 0.7, 1.0),
				vec4(1.0, 1.0, 1.0, 1.0),
				vec3(0.0, 0.0, 3.0)
			);
			
			Material mat = Material(
				vec4(0.5, 0.5, 0.5, 1.0),
				vec4(0.8, 0.8, 0.8, 1.0),
				vec4(1.0, 1.0, 1.0, 1.0),
				200.0
			);
			
			vec4 phong(vec4 color, vec3 normal, vec3 eyePos) {
				vec3 normPos      = normalize(light0.position);
				float LambertTerm = dot(normal, normPos);
				vec3 reflection   = reflect(-normPos, normal);
				
				vec4 Ia = light0.ambient * mat.ambient;
				vec4 Id = light0.diffuse * mat.diffuse * LambertTerm; // light0.diffuse * mat.diffuse * LambertTerm
				vec4 Is = mat.specular * light0.specular * pow(max(dot(reflection, eyePos), 0.0), mat.shininess);
				vec4 If = color*(Ia + Id + Is);
				
				return If;
			}
		</script>
		<script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;
			
			#import <shader-fs-phong>
			
			varying vec4 vColor;
			varying vec3 vNormal;
			varying vec2 vTexCoord;
			varying vec3 vEye;
			
			uniform sampler2D   uSampler;
			uniform samplerCube uSamplerCube;
			uniform int         uTextureMode;
			uniform bool        uUsePicking;
			uniform bool        uHighlight;
			uniform vec4        uBoxId; // this variable is only defined if uUsePicking is true
			
			void main(void) {
				vec4 color;
				
				if (uUsePicking) {
					gl_FragColor = uBoxId;
				} else {
					if (uTextureMode == 1) {
						color = texture2D(uSampler, vTexCoord);
					} else if (uTextureMode == 2) {
						gl_FragColor = textureCube(uSamplerCube, vec3(vTexCoord, 0.0)); // TODO: missing z-tex-coord!
						return;
					} else {
						color = vColor;
					}
					if (uHighlight)
						color *= vec4(10.0, 1.2, 1.2, 1.0);
					gl_FragColor = phong(color, vNormal, vEye);
				}
				
				/* from http://games.greggman.com/game/webgl-techniques-and-performance/
				Question: No WebGL implementation supports multiple render targets. The WebGL spec allows the use of this via
				gl_FragData[i] and DX9 supports the feature. Why is this not implemented?
				
				Answer: One of WebGLâ€™s specific goals is that it should be able to run anywhere that OpenGL ES 2.0 runs.
				That includes iOS, Android and WebOS devices for example. None of those support multiple render targets and while it might
				be possible to emulate it would be a lot of work and be extremely slow. If and when OpenGL ES 3.0 comes out, if it supports
				multiple render targets then maybe WebGL 2.0 will support them. If you feel strongly about this bring it up on the
				Public WebGL mailing list. */
				//gl_FragData[0] = uBoxId; // gl_MaxDrawBuffers is always 1 in WebGL 1.0
			}
		</script>
		<script src="js/game.js" type="text/javascript"></script>
		<style>
			body {
				text-align: center;
				margin: 0;
			}
			
			#canvas {
				position: relative;
				background-image: url(ice.jpg);
				text-align: left;
			}
			
			#glcanvas {
				position: absolute;
				top: 0; left: 0;
				width: 100%; height: 100%;
				z-index: 3;
			}
			
			.switch {
				background: gold;
				border-radius: 25px;
			}
			
			.box {
				background: brown;
				border: 1px solid #eee;
			}
			
			.obstacle {
				background: #969696;
			}
		</style>
	</head>
	<body>
		<canvas id="glcanvas">
			Your browser does not support the &lt;canvas&gt; element!
		</canvas>
		
		<!--<div id="canvas"></div>
		<div style="position: absolute; float: left;">
			<button onclick="initMap(map1);">Load map 1</button>
			<button onclick="initMap(map2);">Load map 2</button>
			<button onclick="initMap(map3);">Load map 3</button>
			<button onclick="initMap(map4);">Load map 4</button>
			<button onclick="initMap(map5);">Load map 5</button>
		</div>-->
	</body>
</html>
